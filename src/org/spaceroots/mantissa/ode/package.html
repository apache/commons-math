<html>
<body>
This package provides classes to solve Ordinary Differential Equations problems.

<p>
This package solves Initial Value Problems of the form
<code>y'=f(t,y)</code> with <code>t0</code> and <code>y(t0)=y0</code>
known. The provided integrators compute an estimate of
<code>y(t)</code> from <code>t=t0</code> to <code>t=t1</code>.
</p>

<p>
All integrators provide dense output. This means that besides
computing the state vector at discrete times, they also provide a
cheap mean to get the state between the time steps. They do so through
classes extending the {@link
org.spaceroots.mantissa.ode.StepInterpolator StepInterpolator}
abstract class, which are made available to the user at the end of
each step.
</p>

<p>
All integrators handle multiple switching functions. This means that
the integrator can be driven by discrete events (occurring when the
signs of user-supplied {@link
org.spaceroots.mantissa.ode.SwitchingFunction switching functions}
change). The steps are shortened as needed to ensure the events occur
at step boundaries (even if the integrator is a fixed-step
integrator). When the events are triggered, integration can be stopped
(this is called a G-stop facility), the state vector can be changed,
or integration can simply go on. The latter case is useful to handle
discontinuities in the differential equations gracefully and get
accurate dense output even close to the discontinuity. The events are
detected when the functions signs are different at the beginning and
end of the current step, or at several equidistant points inside the
step if its length becomes larger than the maximal checking interval
specified for the given switching function. This time interval should
be set appropriately to avoid missing some switching function sign
changes (it is possible to set it to
<code>Double.POSITIVE_INFINITY</code> if the sign changes cannot be
missed).
</p>

<p>
The user should describe his problem in his own classes
(<code>UserProblem</code> in the diagram below) which should implement
the {@link org.spaceroots.mantissa.ode.FirstOrderDifferentialEquations
FirstOrderDifferentialEquations} interface. Then he should pass it to
the integrator he prefers among all the classes that implement the
{@link org.spaceroots.mantissa.ode.FirstOrderIntegrator
FirstOrderIntegrator} interface. In order to simplify the mapping
between domain objects and the flat arrays needed in order to
implement the {@link
org.spaceroots.mantissa.ode.FirstOrderDifferentialEquations
FirstOrderDifferentialEquations} interface, the {@link
org.spaceroots.mantissa.utilities.ArraySliceMappable
ArraySliceMappable} interface and {@link
org.spaceroots.mantissa.utilities.ArrayMapper ArrayMapper} class
provided by the utilities package can be used.
</p>

<p>
The solution of the integration problem is provided by two means. The
first one is aimed towards simple use: the state vector at the end of
the integration process is copied in the <code>y</code> array of the
{@link org.spaceroots.mantissa.ode.FirstOrderIntegrator#integrate
FirstOrderIntegrator.integrate} method. The second one should be used
when more in-depth information is needed throughout the integration
process. The user can register an object implementing the {@link
org.spaceroots.mantissa.ode.StepHandler StepHandler} interface or a
{@link org.spaceroots.mantissa.ode.StepNormalizer StepNormalizer}
object wrapping a user-specified object implementing the {@link
org.spaceroots.mantissa.ode.FixedStepHandler FixedStepHandler}
interface into the integrator before calling the {@link
org.spaceroots.mantissa.ode.FirstOrderIntegrator#integrate
FirstOrderIntegrator.integrate} method. The user object will be called
appropriately during the integration process, allowing the user to
process intermediate results. The default step handler does nothing.
</p>

<p>
{@link org.spaceroots.mantissa.ode.ContinuousOutputModel
ContinuousOutputModel} is a special-purpose step handler that is able
to store all steps and to provide transparent access to any
intermediate result once the integration is over. An important feature
of this class is that it implements the <code>Serializable</code>
interface. This means that a complete continuous model of the
integrated function througout the integration range can be serialized
and reused later (if stored into a persistent medium like a filesystem
or a database) or elsewhere (if sent to another application). Only the
result of the integration is stored, there is no reference to the
integrated problem by itself.
</p>

<p>
Other default implementations of the {@link
org.spaceroots.mantissa.ode.StepHandler StepHandler} interface are
available for general needs ({@link
org.spaceroots.mantissa.ode.DummyStepHandler DummyStepHandler}, {@link
org.spaceroots.mantissa.ode.StepNormalizer StepNormalizer}) and custom
implementations can be developped for specific needs. As an example,
if an application is to be completely driven by the integration
process, then most of the application code will be run inside a step
handler specific to this application.
</p>

<p>
Some integrators (the simple ones) use fixed steps that are set at
creation time. The more efficient integrators use variable steps that
are handled internally in order to control the integration error with
respect to a specified accuracy (these integrators extend the {@link
org.spaceroots.mantissa.ode.AdaptiveStepsizeIntegrator
AdaptiveStepsizeIntegrator} abstract class). In this case, the step
handler which is called after each successful step shows up the
variable stepsize. The {@link
org.spaceroots.mantissa.ode.StepNormalizer StepNormalizer} class can
be used to convert the variable stepsize into a fixed stepsize that
can be handled by classes implementing the {@link
org.spaceroots.mantissa.ode.FixedStepHandler FixedStepHandler}
interface. Adaptive stepsize integrators can automatically compute the
initial stepsize by themselves, however the user can specify it if he
prefers to retain full control over the integration or if the
automatic guess is wrong.
</p>

<p>
<table border="1" align="center">
<tr BGCOLOR="#CCCCFF"><td colspan=2><font size="+2">Fixed Step Integrators</font></td></tr>
<tr BGCOLOR="#EEEEFF"><font size="+1"><td>Name</td><td>Order</td></font></tr>
<tr><td>{@link org.spaceroots.mantissa.ode.EulerIntegrator Euler}</td><td>1</td></tr>
<tr><td>{@link org.spaceroots.mantissa.ode.MidpointIntegrator Midpoint}</td><td>2</td></tr>
<tr><td>{@link org.spaceroots.mantissa.ode.ClassicalRungeKuttaIntegrator Classical Runge-Kutta}</td><td>4</td></tr>
<tr><td>{@link org.spaceroots.mantissa.ode.GillIntegrator Gill}</td><td>4</td></tr>
<tr><td>{@link org.spaceroots.mantissa.ode.ThreeEighthesIntegrator 3/8}</td><td>4</td></tr>
</table>
</p>

<table border="1" align="center">
<tr BGCOLOR="#CCCCFF"><td colspan=3><font size="+2">Adaptive Stepsize Integrators</font></td></tr>
<tr BGCOLOR="#EEEEFF"><font size="+1"><td>Name</td><td>Integration Order</td><td>Error Estimation Order</td></font></tr>
<tr><td>{@link org.spaceroots.mantissa.ode.HighamHall54Integrator Higham and Hall}</td><td>5</td><td>4</td></tr>
<tr><td>{@link org.spaceroots.mantissa.ode.DormandPrince54Integrator Dormand-Prince 5(4)}</td><td>5</td><td>4</td></tr>
<tr><td>{@link org.spaceroots.mantissa.ode.DormandPrince853Integrator Dormand-Prince 8(5,3)}</td><td>8</td><td>5 and 3</td></tr>
<tr><td>{@link org.spaceroots.mantissa.ode.GraggBulirschStoerIntegrator Gragg-Bulirsch-Stoer}</td><td>variable (up to 18 by default)</td><td>variable</td></tr>
</table>
</p>

<p>
The class diagram below shows a typical example use of this
package. The orange boxes are the classes the user should develop, the
white boxes are the interfaces and classes already provided by the
library. The main application build an ODE problem that involve
several domain objects (for example the orbit of a spacecraft and its
attitude) which are mapped into one flat array representing the state
vector using an ArrayMapper object. The UserProblem object is provided
by the main application to an integrator (in this exemple the
Gragg-Bulirsch-Stoer integrator has been chosen) together with a step
handler (in this exemple the already existing ContinuousOutputModel
class has been chosen). In this case, the user waits until the end of
integration before continuing his own processing, and uses the
ContinuousOutputModel object to navigate throughout the integration
interval once it has been filled up by the integrator.
</p>

<img src="doc-files/org_spaceroots_mantissa_ode_classes.png" />

@author L. Maisonobe
</body>
</html>
